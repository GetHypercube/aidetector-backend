import argparse
import time
import json
import logging
from PIL import Image
from PIL.ExifTags import TAGS
from PIL.PngImagePlugin import PngImageFile
from utils import (
    setup_logger,
    validate_image_file,
)

logger = setup_logger(__name__)


def process_image(image_path):
    """
    Extracts the EXIF information from an image and checks against a list of
    synthetic generators to determine if it's generated by any of them.

    :param image_path: Path to the image file
    :param generators: List of dicts, each containing the name of the
    generator and fields to check with their expected values or patterns
    :return: Name of the synthetic generator if matched, else None
    """

    start_time = time.time()

    # Maximum number of pixels allowed in an image
    # MAX_PIXELS = 128 * 1000000

    # Read the image data using PIL
    image = Image.open(image_path)
    image.load()

    try:
        validate_image_file(image_path)
    except ValueError as e:
        return ({"error": str(e)})

    exif_dict = {}

    # Obtain basic metadata

    logger.debug("Extracting basic metadata...")

    basic_metadata = {
        "Filename": image.filename,
        "Image size": image.size,
        "Image height": image.height,
        "Image width": image.width,
        "Image format": image.format,
        "Image mode": image.mode,
        "Image is animated": getattr(image, "is_animated", False),
        "Frames in the mage": getattr(image, "n_frames", 1),
    }

    for label, value in basic_metadata.items():
        logger.debug(f"{label:25}: {value}")
        exif_dict[label] = value

    logger.debug("Extracting additional metadata...")

    exifdata = image.getexif()
    # Iterating over all EXIF data fields
    for tag_id in exifdata:
        # Get the tag name, instead of human unreadable tag id
        key = TAGS.get(tag_id, tag_id)
        data = exifdata.get(tag_id)
        # Decode bytes
        if isinstance(data, bytes):
            data = data.decode()
        if key not in exif_dict:
            logger.debug(f"{key:25}: {data}")
            exif_dict[key] = data

    if isinstance(image, PngImageFile):
        logger.debug("Extracting ICC profile...")
        # Extract ICC Profile
        icc_profile = image.info.get('icc_profile')
        if icc_profile:
            exif_dict['ICC Profile'] = 'Available'
        else:
            exif_dict['ICC Profile'] = 'Not available'

        # Extract text chunks
        for key in image.info:
            if key in ['text', 'itxt', 'ztxt']:
                if key not in exif_dict:
                    exif_dict[key] = image.info[key]
                    logger.debug(f"{key:25}: {image.info[key]}")

    # Iterate over image.info and add to exif_dict
    for key, value in image.info.items():
        if key not in exif_dict:  # Avoid overwriting existing EXIF data
            exif_dict[key] = value

    print(exif_dict)

    execution_time = time.time() - start_time

    if 'Author' in exif_dict and 'Description' in exif_dict and "Job ID:" in exif_dict['Description']:
        isSyntheticImage = True
        inferedModel = "Midjourney"
    else:
        isSyntheticImage = False
        inferedModel = None

    detection_output = {
        "model": "exif-model-detector",
        "inferenceResults": {
            "isSyntheticImage": isSyntheticImage,
            "inferedModel": inferedModel,
            "executionTime": execution_time,
        },
    }

    return detection_output


def main():
    """
    Command-line interface for the GAN detector.
    """
    parser = argparse.ArgumentParser(
        description="EXIF detector inference on a single image"
    )
    parser.add_argument(
        "--image_path", type=str, required=True, help="Path to the image file"
    )
    parser.add_argument(
        "--log_level",
        type=str,
        default="DEBUG",
        help="Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)",
    )

    args = parser.parse_args()
    # Configure logger
    log_levels = {
        "DEBUG": logging.DEBUG,
        "INFO": logging.INFO,
        "WARNING": logging.WARNING,
        "ERROR": logging.ERROR,
        "CRITICAL": logging.CRITICAL,
    }
    setup_logger(__name__, log_levels.get(args.log_level.upper(), logging.DEBUG))
    return process_image(args.image_path)


if __name__ == "__main__":
    output = main()
    print(json.dumps(output, indent=4))
