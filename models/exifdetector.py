"""
Exif Detector: Inference on a single image using meta information
"""

import re
import time
from PIL import Image
from PIL.ExifTags import TAGS
from PIL.PngImagePlugin import PngImageFile
from utils.general import (
    setup_logger,
    validate_image_file,
)

logger = setup_logger(__name__)


def process_image(image_path, original_filename):
    """
    Extracts the EXIF information from an image and checks against a list of
    synthetic generators to determine if it's generated by any of them.

    :param image_path: Path to the image file
    :param generators: List of dicts, each containing the name of the
    generator and fields to check with their expected values or patterns
    :return: Name of the synthetic generator if matched, else None
    """

    start_time = time.time()

    # Maximum number of pixels allowed in an image
    # @TODO: MAX_PIXELS = 128 * 1000000

    # Read the image data using PIL
    image = Image.open(image_path)
    image.load()

    try:
        validate_image_file(image_path)
    except ValueError as e:
        return {"error": str(e)}

    exif_dict = {}

    # Obtain basic metadata

    logger.debug("Extracting basic metadata...")

    basic_metadata = {
        "Filename": image.filename,
        "Image size": image.size,
        "Image height": image.height,
        "Image width": image.width,
        "Image format": image.format,
        "Image mode": image.mode,
        "Image is animated": getattr(image, "is_animated", False),
        "Frames in the mage": getattr(image, "n_frames", 1),
    }

    for label, value in basic_metadata.items():
        logger.debug("%-25s: %s", label, value)
        exif_dict[label] = value

    logger.debug("Extracting additional metadata...")

    exifdata = image.getexif()
    # Iterating over all EXIF data fields
    for tag_id in exifdata:
        # Get the tag name, instead of human unreadable tag id
        key = TAGS.get(tag_id, tag_id)
        data = exifdata.get(tag_id)
        # Decode bytes
        if isinstance(data, bytes):
            data = data.decode()
        if key not in exif_dict:
            logger.debug("%-25s: %s", key, data)
            exif_dict[key] = data

    if isinstance(image, PngImageFile):
        logger.debug("Extracting ICC profile...")
        # Extract ICC Profile
        icc_profile = image.info.get("icc_profile")
        if icc_profile:
            exif_dict["ICC Profile"] = "Available"
        else:
            exif_dict["ICC Profile"] = "Not available"

        # Extract text chunks
        for key in image.info:
            if key in ["text", "itxt", "ztxt"]:
                if key not in exif_dict:
                    exif_dict[key] = image.info[key]
                    logger.debug("%-25s: %s", key, image.info[key])

    # Iterate over image.info and add to exif_dict
    for key, value in image.info.items():
        if key not in exif_dict:  # Avoid overwriting existing EXIF data
            exif_dict[key] = value

    logger.debug("%s", exif_dict)

    execution_time = time.time() - start_time

    # # Regex for DALL-E filename pattern
    # @TODO: Make it more specific
    dalle_regex = r"DALLÂ·E \d{4}-\d{2}-\d{2} \d{2}\.\d{2}\.\d{2}"

    logger.info("Applying regex to %s", original_filename)

    if re.match(dalle_regex, original_filename):
        is_synthetic_image = True
        infered_model = "DALLE-3"
    elif (
        "Author" in exif_dict
        and "Description" in exif_dict
        and "Job ID:" in exif_dict["Description"]
    ):
        is_synthetic_image = True
        infered_model = "Midjourney"
    elif(
        "parameters" in exif_dict
        and "prompt:" in exif_dict["parameters"]
    ):
        is_synthetic_image = True
        infered_model = "Stable Diffusion"
    else:
        is_synthetic_image = False
        infered_model = None

    detection_output = {
        # "model": "exif-model-detector",
        "inferenceResults": {
            "isSyntheticImage": is_synthetic_image,
            "inferedModel": infered_model,
            "executionTime": execution_time,
        },
    }

    return detection_output
